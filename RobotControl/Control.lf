target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
}

import Motors from "../lib/Motors.lf"
import Display from "../lib/Display.lf"
import lanesFromInt from "../lib/lanesFromInt.lf"
//import Encoders from "../lib/Encoders.lf"
//import GyroAngle from "../lib/IMU.lf"
//import Accelerometer from "../lib/IMU.lf"

preamble {=
    #include <pico/stdlib.h>
    #include <imu.h>
    //uart imports
    #include <stdio.h>
    #include "pico/stdlib.h"
    #include "hardware/uart.h"
    #include <hardware/gpio.h>
    //UART Defines
    #define UART_ID uart0
    #define BAUD_RATE 115200
    #define UART_TX_PIN 28
    #define UART_RX_PIN 29
    #define MAX_STRING_LENGTH 256

    //Lane Value Defines
    #define LEFT_CENTER 165
    #define RIGHT_CENTER 1745
    #define THRESH 30

    //Lane Check Functions
    static int isLeftCenter(int left) {
        return left <= LEFT_CENTER + THRESH && left >= LEFT_CENTER - THRESH;
    }
    static int isRightCenter(int right) {
        return right <= RIGHT_CENTER + THRESH && right >= RIGHT_CENTER - THRESH;
    }
    static int isLeftTurnLeft(int left) {
        return left < LEFT_CENTER - THRESH;
    }
    static int isRightTurnLeft(int right) {
        return right < RIGHT_CENTER - THRESH;
    }
    static int isLeftTurnRight(int left) {
        return left > LEFT_CENTER + THRESH;
    }
    static int isRightTurnRight(int right) {
        return right > RIGHT_CENTER + THRESH;
    }

 =}

main reactor {
    m = new Motors()
    d = new Display()
    lane = new lanesFromInt()
    timer uart_poll(0, 250 ms)

    reaction(startup) -> lane.encodedLanes, d.line3 {=
        static char buf[17];
        snprintf(buf, 17, "Enter Setup");
        lf_set(d.line3, buf);
        stdio_init_all();

        //Status LED Init
        gpio_init(PICO_DEFAULT_LED_PIN);
        gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
        
        //UART Init
        uart_init(UART_ID, BAUD_RATE);
        gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
        gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);
        uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);

        //Lane Init
        lf_set(lane.encodedLanes, 1920);
        snprintf(buf, 17, "Finish Setup");
        lf_set(d.line3, buf);
    =}

    reaction(uart_poll) -> lane.encodedLanes {=
        char buffer[20];
        int i = 0;

        printf("Enter uart poll\n ");
 
        while(1) {
            printf("loop ");
            char c = uart_getc(UART_ID);
            if (c=='\n') {
                buffer[i] = '\0';
                break;
            }
            buffer[i++] = c;
            if (i >= sizeof(buffer)-1) {
                buffer[i] = '\0';
                break;
            }
        }
        printf("exit loop\n");
        int lanes = atoi(buffer);
        lf_set(lane.encodedLanes, lanes);
    =}

    initial mode Standby {
        reaction(lane.left, lane.right) -> m.left_power, m.right_power, Standby, Straight, Left, Right {=
            printf("Entering Standby\n");
            printf("Lane Values %d %d\n", lane.left->value, lane.right->value);
            if(isLeftCenter(lane.left->value) && isRightCenter(lane.right->value)) {
                lf_set(m.left_power, 0.2f);
                lf_set(m.right_power, 0.2f);
                lf_set_mode(Straight);
            } 
            if(isLeftTurnLeft(lane.left->value) && isRightTurnLeft(lane.right->value)) {
                lf_set_mode(Standby);
            }
            if(isLeftTurnRight(lane.left->value) && isRightTurnRight(lane.right->value)) {
                lf_set_mode(Standby);
            }
        =}
    }

    mode Straight {
        reaction(lane.left, lane.right) -> m.left_power, m.right_power, Left, Right, mergeLeft, mergeRight, Standby {= 
            printf("Entering Straight\n");
            if(isLeftTurnLeft(lane.left->value) && isRightTurnLeft(lane.right->value)) {
                lf_set_mode(Standby);
            }
            if(isLeftTurnRight(lane.left->value) && isRightTurnRight(lane.right->value)) {
                lf_set_mode(Standby);
            }
            if(isLeftCenter(lane.left->value) && isRightTurnLeft(lane.right->value)) {
                lf_set_mode(Standby);
            }
            if(isLeftTurnRight(lane.left->value) && isRightCenter(lane.right->value)) {
                lf_set_mode(Standby);
            }
            if(lane.left->value == 0 && lane.right->value == 1920) {
                lf_set_mode(Standby);
            }
        =}
    }

    mode Left {
        reaction(lane.left, lane.right) -> m.left_power, m.right_power, Straight, Right, mergeLeft, mergeRight, Standby {= 
            printf("Entering Left\n");
            if(isLeftCenter(lane.left->value) && isRightCenter(lane.right->value)) {
                lf_set_mode(Straight);
            } 
            if(isLeftTurnRight(lane.left->value) && isRightTurnRight(lane.right->value)) {
                lf_set_mode(Right);
            }
            if(isLeftCenter(lane.left->value) && isRightTurnLeft(lane.right->value)) {
                lf_set_mode(mergeLeft);
            }
            if(isLeftTurnRight(lane.left->value) && isRightCenter(lane.right->value)) {
                lf_set_mode(mergeRight);
            }
            if(lane.left->value == 0 && lane.right->value == 1920) {
                lf_set_mode(Standby);
            }
        =}
    }

    mode Right {
        reaction(lane.left, lane.right) -> m.left_power, m.right_power, Straight, Left, mergeLeft, mergeRight, Standby {= 
            printf("Entering Right\n");
            if(isLeftCenter(lane.left->value) && isRightCenter(lane.right->value)) {
                lf_set_mode(Straight);
            } 
            if(isLeftTurnLeft(lane.left->value) && isRightTurnLeft(lane.right->value)) {
                lf_set_mode(Left);
            }
            if(isLeftCenter(lane.left->value) && isRightTurnLeft(lane.right->value)) {
                lf_set_mode(mergeLeft);
            }
            if(isLeftTurnRight(lane.left->value) && isRightCenter(lane.right->value)) {
                lf_set_mode(mergeRight);
            }
            if(lane.left->value == 0 && lane.right->value == 1920) {
                lf_set_mode(Standby);
            }
        =}
    }

    mode mergeLeft {
        reaction(lane.left, lane.right) -> m.left_power, m.right_power, Standby {=
            printf("Entering Merge Left\n");
            lf_set_mode(Standby);
        =}
    }

    mode mergeRight {
        reaction(lane.left, lane.right) -> m.left_power, m.right_power, Standby {=
            printf("Entering Merge Right\n");
            lf_set_mode(Standby);
        =}
    }
}
